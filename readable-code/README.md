# Readable-code (clean-code)

## 용어 정리
### 도메인(domain)
- 해결하고자 하는 문제 영역

### 도메인 지식
- 도메인을 이해하고 해결하는 데 필요한 지식

----------

## **클린 코드**를 추구하는 이유

### 가독성 (Readability) 
- 글(코드)이 잘 읽힌다.  
   = 이해가 잘 된다.  
   = 유지보수하기가 수월하다.  
   = 개발자의 시간과 자원이 절약된다.  

----------

## 추상과 구체 

### 추상
중요한 정보는 **가려내어** 남기고, 덜 중요한 정보는 생략하여 **버린다**.

적절한 추상화는 복잡한 데이터와 복잡한 로직을 단순화하여 이해하기 쉽도록 돕는다.  
= 읽기가 좋다.
하지만 "잘못된 추상화"가 야기하는 side-effect는 생각보다 정말로 크다.

"적절한 추상화"는 해당 **도메인의 문맥** 안에서, 정말 중요한 핵심 개념만 남겨서 표현하는 것.
</br>

### 추상화의 가장 대표적인 행위
-> 이름을 짓는다 (네이밍)  
**가장 단순하면서, 아주 중요한, 고도의 추상적 사고 행위**

### 이름 짓기
이름을 짓는다는 행위는 **추상적 사고**를 기반으로 한다.

- 단수와 복수를 구분하기
- 이름 줄이지 않기
- 은어/방어 사용하지 않기
- 좋은 코드를 보고 습득하기

## 매직 넘버, 매직 스트링
- 의미를 갖고 있으나, 상수로 추출되지 않은 숫자, 문자열 등
- 상수 추출로 이름을 짓고 의미를 부여함으로써 가독성, 유지보수성 증가

### 상수(변하지 않는 값)로 추출한다는 것의 의미
이름을 부여하는 것은 추상화를 하는 행위  
-> 상수로 추출한다는 것은 일종의 이름을 부여하는 행위 (= 즉, 추상화 행위)

## 추상의 관점으로 바라보는 객체 지향

### 관심사의 분리
높은 응집도, 낮은 결합도

## SOLID
### 단일 책임 원칙 (SRP: Single Responsibility Principle)
- 하나의 클래스는 단 한가지의 변경 이유만을 가져야 한다.  
-> 변경 이유 = 책임
- 객체가 가진 공개 메서드, 필드, 상수 등은 해당 객체의 단일 책임에 의해서만 변경 되는가?
- 관심사의 분리
- 높은 응집도, 낮은 결합도

### 리스코프 치환 원칙 (LSP: Liskov Substitution Principle)
- 상속 구조에서 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.  
-> 자식 클래스는 부모 클래스의 책임을 준수하며, 부모 클래스의 행동을 변경하지 않아야 한다.
- LSP를 위반하면, 상속 클래스를 사용할 때, 오동작, 예상 밖의 예외가 발생하거나, 이를 방지하기 위한 불필요한 타입 체크가 동반될 수 있다,

### 인터페이스 분리 원칙 (ISP: Interface Segregation Principle)
- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 된다.  
-> 인터페이스를 잘게 쪼개라!
- ISP를 위반하면, 불필요한 의존성으로 인해 결합도가 높아지고, 특정 기능의 변경이 여러 클래스에 영향을 미칠 수 있다.

### 의존성 역전 원칙 (DIP: Dependency Inversion Principle)
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.  
둘 모두 추상화에 의존해야 한다.
- 의존성의 순방향: 고수준 모듈이 저수준 모듈을 참조하는 것
- 의존성의 역방향: 고수준, 저수준 모듈이 모두 추상화에 의존하는 것  
-> 저수준 모듈이 변경되어도, 고수준 모듈에는 영향이 가지 않는다.

## DIP, DI, IoC
- DIP (Dependency Inversion Principle): 고수준, 저수준 모듈이 추상화에 의존하도록 하는 것
- DI (Dependency Injection): 의존성 주입은 필요한 의존성을 직접 생성하는 것이 아닌, 외부에서 주입 받아 사용하는 것
- IoC (Inversion of Control): 제어의 역전 프로그램의 흐름을 개발자가 아닌 프레임워크 같은 도구가 제어하는 것
