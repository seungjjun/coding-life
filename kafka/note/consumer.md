# Consumer

프로듀서가 전송한 데이터는 카프카 브로커에 적재된다.  
컨슈머는 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다. 

## 컨슈머 내부 구조
클러스터 -> Fetcher(poll()) -> ConsumerRecords

- Fetcher: 리더 파티션으로부터 데이터를 미리 가져와 대기.
- poll(): Fetcher에 있는 레코드들을 리턴하는 레코드
- ConsumerRecords: 처리하고자 하는 레코드들의 모음. 오프셋이 포함되어 있다.
  - 레코드의 오프셋 번호를 확인하여 처리가 왼료되었을 경우 "커밋"이라는 과정을 통하여 레코드를 처리했다고 표시한다.

## 컨슈머 그룹(Consumer Group)
컨슈머 그룹은 여러 컨슈머가 함께 하나의 그룹으로 묶여서 토픽의 데이터를 분산 처리하는 방식을 말한다. 이를 통해 데이터 처리의 효율성과 확장성을 높일 수 있다.
- 컨슈머 그룹은 메시지를 병렬로 처리하기 위해 설계된 구조이다.  
- 같은 그룹에 속한 컨슈머들은 서로 다른 파티션을 할당받아 독립적으로 메시지를 처리한다.
- 예를 들어, 3개의 파티션이 있는 토픽과 3명의 컨슈머가 있을 때, 각 컨슈머는 하나의 파티션을 할당받아 메시지를 병렬로 처리하게 된다.  

1개의 파티션은 최대 1개의 컨슈머에 할당 가능하다. 1개의 컨슈머는 여러 개의 파티션에 할당이 가능하다.  
컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야 한다.  

만일 컨슈머 그룹의 컨슈머 개수가 파티션 개수보다 많으면 파티션을 할당받지 못한 유휴 상태인 컨슈마가 발생한다.  

## 리밸런싱(rebalancing)
리밸런싱은 토픽과 파티션의 할당 과정이 변경되는 과정이다. (예를 들어 컨슈머 그룹에 새로운 컨슈머가 추가되거나 기존 컨슈머가 제거될 때 파티션 할당을 재조정하는 과정)  
이 과정에서 일시적으로 메시지 처리가 중단될 수 있다.  

- 파티션의 개수가 많아질수록 리밸런싱 하는 과정의 시간이 길어지기 때문에 리밸런싱에 대응하는 코드를 작성해야 한다.

## 커밋(commit)
컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록한다.  
특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지 카프카 브로커 내부에서 사용되는 내부 토픽(__consumer_offsets)에 기록된다.  

## 컨슈머 랙(LAG)
컨슈머 랙은 파티션의 최신 오프셋과 컨슈머 오프셋간의 차이다. (프로듀서와 컨슈머의 데이터 처리량의 차이)
- 예를 들어 프로듀서가 생성한 레코드의 오프셋이 4인데 현재 컨슈머가 처리한 레코드의 최신 오프셋이 2인 경우 컨슈머 랙이 2 정도 발생했다고 볼 수 있다.
- 지연이 클 수록 컨슈머의 처리량이 늦어져 애플리케이션의 데이터 처리에 지연이 발생하고 있다는 이야기이다.
